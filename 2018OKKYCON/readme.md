# 2018 OKKYCON - The Real TDD

연사진

- 정진욱 - 테스트하기 쉬운 코드로 개발하기
- 박재성 - 의식적인 연습으로 TDD, 리팩토링 연습하기
- 한성곤 - 코드 품질을 위한 테스트 주도 개발
- 이혜승 - 테알못 신입은 어떻게 테스트를 시작했을까?
- 양완수 - 테스트를 돌보기 위한 간단한 실천 방법, 효과
- 이규원 - 당신들의 TDD가 실패하는 이유 (Live Coding)



## 정진욱 - 테스트하기 쉬운 코드

### 테스트하기 쉬운 코드란?

- 같은 입력에 항상 같은 결과를 반환하는 코드

- 외부상태를 변경하지 않는 코드



예제 - 컨퍼런스 등록 Web Api

1. ConferenceRegistration 유효성 검사
2. **이미 등록된 좌석 수 DB에서 읽어오기**
3. 요청한 좌석 수가 확보 가능한지 판단
4. **등록정보저장**
5. HTTP결과반환

위 5가지 중 테스트하기 어려운 것은?

DB와 연동이 필요한 항목인 2, 3번이다



**테스트하기 힘든 코드를 포함하고 있는 메서드는 테스트하기 힘들다**

**테스트하기 쉬운 코드와 어려운 코드는 분리하자**

![1539919874850](C:\Users\David\Desktop\2018OKKYCON\assets\1539919874850.png)



### 테스트 하기 쉬운 코드로 개발하는 방법

- 메소드를 분리한다

- 두 부류(테스트 하기 쉬운 코드, 어려운 코드)코드는 어디서 만나야 하는가?

  두 부류의 코드는 최대한 가장 자리에 위치시키자 (예외 : 로깅, 퍼사드)

  * 제일 안쪽에 있는 메서드가 테스트하기 어려우면 이를 호출하는 메서드들도 테스트하기 어려움즉, 바깥으로 테스트의 어려움이 전파됨
  * 따라서 테스트하기 어려운 메서드를 가장 바깥으로 빼서 테스트하기 쉬운 코드랑 만나게 하자, 그러면 테스트 하기 어려운 코드가 전파하는 악영향을 줄일 수 있다

- 두 부류의 코드가 만나는 가장자리는 어떻게 테스트하는가?

  - 수동테스트
    - 웹의 경우 postman 같은 것으로 요청을 날린다
    - DB의 경우 query를 날린다
    - 다만 이렇게 수동으로 가능한 경우는 자동화가 필요없을 정도로 간단한 것들이 대부분이다
  - 자동테스트
    - 이미 작성된 프로덕션 코드의 사용을 강제하자
    - 실제 클래스 대신 목(Mock) 사용을 위해 이음새(Seam)가 있어야 함
    - 목 사용을 통해 작성된 코드 사용을 강제할 수 있음
    - 행위 검증 (목 사용)
      - 행위가 노출되었는가?
      - Mockist
      - 불필요한 추상화 유발 가능성
      - 아웃사이드 인 방식
    - 상태 검증
      - 결과 값이 무엇인가?
      - Classicist
      - 불필요한 추상화 필요없음
      - 인사이드 아웃
    - 목 사용의 문제점ㅍ
      - 목을 남발할 가능성이 크다
        - 대부분 목 사용 예제는 간단하다
        - 실제 프로젝트에 적용하면 한꺼번에 많은 목을 다루면서 진행하기 힘들다
      - 적당 수의 목 사용에 대한 답을 찾기 어렵다
    - 상태 검증에 대한 문제 극복 방안
      - TDD를 통한 사전 테스트가 아니라 사후테스트를 하자
      - 두 부류의 코드가 맞물려 잘 돌아가는 로직이다
      - 난해한 코드가 아니다

두 부류의 코드를 분리해서 각각 테스트하고 가장자리에 맞물려 돌아가는 코드는 주로 수동테스트한다

두 부류의 코드를 섞어 놓고 테스트가 어렵다고 포기하지 말자



TDD 원칙 중 하나

테스트를 만족하는 정도만 코드를 작성하라

그 이상을 작성하게 되면 테스트 커버 안에 들지 않는다

테스트1 < 코드1 + 코드2 + 코드3

TDD는 점진적 향상이라는 것이 있는데 이 장점을 잃는다



**테스트 하기 어렵다는 것은 테스트가 불가능 하다는 것이 아니다**



### 질문

* private 메서드 테스트는 어떻게 해야하는가?

  같은 기능을 테스트하더라도 3가지 메서드를 건드리기보다 1가지 메서드를 건드리는 것이 좋다

  어떤 것을 public으로 할 것인지 고민해보면 좋을 것 같다

* 레거시에 대해서는 목을 어떻게 써야 하는가?

  인터페이스를 만들고 목에 대한 seam을 만듦

  새로 생성된 코드는 최대한 레거시와의 의존도를 낮춤

  캐릭터라이제이션이라는 테스트 기법(?)을 통해 기존 코드에 대해 요구사항만 나열해두고 테스트함



정진욱 연사님 Blog : http://jwchung.github.io/testing-oh-my



## 박재성(자바지기) - 의식적인 연습으로 TDD, 리팩토링 연습하기

TDD에서 리팩토링과 설계 얘기가 안 나올 수 없다

TDD < 리팩토링, 어쩌면 리팩토링이 더 중요할지도



### 의식적인 연습이란?

TDD, 리팩토링을 잘 하려면... 연습, 연습, 연습 ...

무조건 연습을 많이 한다고 잘할 수 있을까?

1년차 프로그래머의 프로그래밍 역량 VS 10년차 프로그래머의 프로그래밍 역량

프로그래밍 역량만 놓고 보았을 때 항상 10년차가 낫다고 보장할 수 있나?



TDD, 리팩토링 5~6년 도전 후에야 다음과 같은 것이 생겼다

- **테스트하기 쉬운 코드와 테스트하기 어려운 코드를 보는 눈**
- **테스트하기 어려운 코드를 테스트하기 쉬운 코드로 설계하는 감(sense)**



좀 더 효과적으로 연습할 수 있는 방법은 없을까?

책<1만 시간의 재발견> : "목적 의식 있는 연습"에 얼마나 많은 시간을 투자했느냐?



의식적인 연습의 7가지 원칙

1. 효과적인 훈련 기법이 수립되어 있는 기술 연마
2. 개인의 **컴포트 존을 벗어난 지점에서 진행, 자신의 현재 능력을 살짝 넘어가는 작업을 지속적으로 시도**
3. **명확하고 구체적인 목표**를 가지고 진행

1. 신중하고 계획적이다. 즉, 개인이 온전히 집중하고 '의식적'으로 행동할 것을 요구
2. **피드백과 피드백에 따른 행동 변경을 수반**
3. 효과적인 심적 표상을 만들어내는 한편으로 심적 표상에 의존
4. **기존에 습득한 기술의 특정 부분을 집중적으로 개선함으로써 발전시키고, 수정**하는 과정을 수반



스포츠 영역은 오래되었기 때문에 방법론적인 부분들이 잘 정립되어 있다.

코치가 선수보다 운동은 못할 수 있어도 **연습방법 설계, 피드백을 줄 수 있는 사람**으로써 선수와 다른 역할을 한다



**의식적인 연습을 통해 효과적으로 연습하자**



### 의식적인 연습으로 TDD, 리팩토링 연습 과정

#### 1단계 - 단위 테스트 연습

TDD와 단위테스트는 다르다

**TDD보다 단위 테스트를 먼저 연습해라**

내가 사용하는 API 사용법을 익히기 위한 학습 테스트에서 시작

- 자바 String 클래스의 다양한 메소드 사용법
- 자바 ArrayList 클래스에 대한 메소드 사용법

API를 테스트하므로써 assertThat()에 대한 사용법을 익히는 것 (즉, xUnit에 익숙해지기)

만약, API 학습 테스트가 싫다면 Input과 Output이 명확한 Util성 메소드들로 단위테스트해보자



#### 2단계 - TDD 연습

**지켜야 할 원칙1**

회사 프로젝트에 연습하지 말고 장난감 프로젝트를 활용한다



**지켜야 할 원칙2**

웹, 모바일 UI나 DB, 외부API 등에 의존관계를 가지지 않는 것으로 장난감 프로젝트를 활용한다.



인풋과 아웃풋에 대한 정의를 먼저해야 TDD를 하기 좋다



**TDD 싸이클**

![1_IbHgZrKYCUSeIbL_PywObQ](C:\Users\David\Desktop\2018OKKYCON\assets\1_IbHgZrKYCUSeIbL_PywObQ.png)



**처음에 TDD를 연습한다면 1단계, 2단계만 하고 3단계인 Refactoring은 안해도 좋다**

**익숙하지 않은 데, 한 번에 하려면 힘들 수 있다**



**TDD 연습**

어려운 문제를 해결하는 것이 목적이 아니라 **TDD를 연습하는 것이 목적**이다

난이도가 낮거나 본인에게 익숙한 문제로 연습하는 것이 좋다



**리팩토링 연습**

* **메소드 분리**

  테스트 코드는 변경하지 말고 테스트 대상 코드(프로덕션 코드)를 개선하는 연습을 한다 

  처음에 메소드 분리하려면 머리 아프다



* **정량적인 연습방법**을 통한 메소드 분리 연습
  * 한 메서드에 오직 한 단계의 들여쓰기(indent)만 한다.

    인덴트가 2단계인 곳은 리팩토링 포인트로 생각하면 된다

  * else를 쓰지마라

    - 코드가 짧아진다
    - 읽을 때 좋다
      - else를 쓰면 로직을 파악하기 위해 메서드를 if-else를 통째로 읽어야 한다.

  * 로컬변수가 필요한가?

    * 바로 다른 메서드의 파라미터로 넘겨줄 수는 없나?

  * Compose method패턴

    * 메소드의 추상화 레벨을 맞춘다.
    * 추상화 레벨을 둬서 메소드를 분리했을 때, 필요하다면 로직 파악을 위해 메소드를 타고 들어가서 보면 된다.



	**연습은 과하게 한다.** 
	
	하던대로 하면 잘 안 느껴진다.
	
	마치 달릴 때 모래주머니 차고 달리듯 과하게 해야 느낄 수 있다.
	
	이렇게 극단적인 연습은 전혀 다른 설계를 불러올 수 있다



	일정 압박을 받으며 연습하면 잘 안 된다.
	
	그러므로 장난감 프로젝트로 진행하자



* **클래스 분리**

  * 모든 원시값과 문자열을 포장한다

    예) 숫자로 사용될 값을 사용자 입력 받는다, 이 때 숫자로 사용될 String value를 Positive라는 클래스로 만들어 0 이상을 보장하는 객체로 만들어 쓰는 것

  * 일급 콜렉션을 쓴다
  * 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다



**장난감 프로젝트 난이도 높이기**

TDD, 리팩토링 연습하기 좋은 프로그램 요구사항

- 게임과 같이 요구사항이 명확한 프로그램으로 연습
- 의존관계(UI, DB, 외부API 등)가 없는 것

단, 프로그램에서 UI는 콘솔로만



**의존관계를 추가를 통한 난이도 높이기**

실제 현장과 같은 코드를 TDD하기

이 때 필요한 역량은

- 테스트하기 쉬운 코드와 테스트하기 어려운 코드를 보는 눈
- 테스트하기 어려운 코드를 테스트하기 쉬운 코드로 설계하는 감(sense)



**한 단계 더 나아간 연습을 하고 싶다면**

- 컴파일 에러 최소화하면서 리팩토링
- ATDD 기반으로 통합테스트하기
- 레거시 애플리케이션에 테스트 기반으로 리팩토링하기



**구체적인 연습 목표 찾기**

* **책<쏘트웍스 앤솔러지**>

  객체지향 생활체조 규칙

* 책<**클린코드**>

  메소드 인수 개수, 클래스 크기



하드웨어 비용보다 사람 몸값이 더 부담이다

읽기 좋은 코드를 만드는 것이 경쟁력이다



**TDD, 리팩토링 연습을 위해 필요한 것은?**

- 조급함 대신 마음의 여유
- 나만의 장난감 프로젝트
- 같은 과제를 반복적으로 구현할 수 있는 인내력



### 질문

**컴포트존을 극복하는 노하우는?**

삶의 여유와 에너지가 있어야 한다

컴포트존을 벗어나는 것은 스트레스 받는 것이다

즉, 연습할 수 있는 여유시간을 만들어야 한다

남들하는 거 다하면서 회사다니며 무엇을 바라는가, 1~2년만 각오를 하고 연습을 하자



**테스트 코드를 빡빡하게 짤수록 요구사항이 변경되었을 시 테스트 코드를 바꿔야하는 게 많은데 이를 어떻게 극복할 수 있는가?**

대부분 설계가 잘못된 경우가 많다

시간이 부족한 경우 윗선에 말해 시간을 확보해야 한다

이에 대한 부분들을 우리는 전문가로써 책임을 다해야 한다



## Test Driven Development for Code Quality - 삼성SDS 한성곤

코드레벨 표준화, 측정, 지표



코드품질적인 측면에서 TDD가 어떤 장점을 가지고 있는지?

* TDD는 테스트에 대한 공수가 든다, 단기적으로 측정하기 힘들고 장기적으로 측정해야 한다



### Overview of TDD

TDD cycle

What are the benefits of TDD

- From Test (테스트관점)
  - 동작하는 코드에 대한 자신감
  - 회귀테스트를 통한 자유로운 리팩토링
  - 코드에 대한 지식이 증가 : 테스트 코드 작성하는 것에 대한 자체로 프로덕션 코드에 대한 지식을 높인다
  - **개발 생산성 향상**
  - 테스트를 통한 빠른 피드백
  - 디버깅을 줄일 수 있다
- From Test-first (테스트 우선 관점)
  - 과도한 설계를 피하고, 간결한 인터페이스를 가짐
  - 불필요한 기능(Gold-plating)을 줄임
  - 실행 가능한 문서를 가짐
  - 코드 품질을 높일 수 있다
- Sonar Cloud - Sonar Cube
  - 테스트 커버리지 기준으로 어떤 장점이 있는가?
- 테스트를 통해 코드품질을 높일 수 있지만 다른 방법들도 있다



### Think more about TDD

코드품질이란?(소프트웨어 품질)

Software Quality

- External Quality
  - IBM은 TDD를 통해 실제 릴리즈를 진행했다, KLOC 40% 에러 defact 줄음
  - MS도 TDD와 Non TDD로 구분되게 실험했다
  - 
- Internal Quality
  - 인터널 품질을 잡으려면 개발 컨벤션을 잘 지킬 수 있어야 한다
- Code Quality Metrics
  - 복잡도, 결합도, 응집도

the seen versus off the unseen

### Success with TDD

저의 부족함으로 각종 수식과 처음들어본 용어들이 난무하여 제대로 받아적을 수 없었습니다..



## 테알못 신입은 어떻게 테스트를 시작했을까?

10개월차 주니어

테스트로 개발한지 5개월차

TDD로 개발한 기간은 더 짧다



초보로써 TDD, 테스트를 하면서 배운 것과 실패한 것 그리고 경험담



### 방법에 대한 이야기

TDD (Test First)

	테스트를 먼저 작성하고 프로덕션 코드를 만드는 것

Test Last

	이미 구현된 코드에 테스트만 붙여두는 것



TDD의 red는 실패,

Test Last의 red는 버그



단위 테스트 코드 작성

* 프로덕션 코드는 전혀 수정하지 않는다.

* 테스트를 만들 때 의도한 인풋과 아웃풋이 나오는지 확인하면 된다.



리팩토링

* 테스트 코드는 전혀 수정하지 않는다.



**테스트 가능한 부분을 분리하는 기준**

- 중요도가 높은 비즈니스 로직이 포함된 부분

- 버그가 발견된 부분 (과거X)

- 결합이 낮고 논리는 복잡한 부분



외부 의존도가 낮은 독립적인 함수를 만들기 위해 외부 의존을 가지는 애들을 함수의 파라미터로 빼준다.



### 경험에 대한 이야기

좋은 점

- 불안함이 감소한다

- 리팩토링을 안정적으로 할 수 있다

- 추가적인 요구사항을 받아도 스트레스 받지 않는다

- 스펙 문서 기능을 한다. 함수를 사용할 때 테스트를 통해 프로덕션 코드를 이해할 수 있다.

- 디자인 개선 효과(설계 얘기)

  - 자바스크립트의 경우 반환 값이 2개이상일 수 있다. 반환 값이 1개만 되도록 테스트를 통해 바로 잡을 수 있다.

- 학습 동기부여

  - 설계에 대한 고민을 자연스럽게 하게 된다

- 개발 생산성 향상

  - 디버깅 하는 시간 줄어들음
  - 테스트 안 해서 아낀 시간 <= 테스트 안 해서 발생한 버그를 고친 시간
  - 비즈니스 로직의 허점을 사전에 발견할 수 있다. 
  - 테스트를 만들면서 비즈니스 로직, 요구사항 등에 대해 깊은 생각을 하게 된다. 이 과정에서 부족한 로직을 보충할 수 있다

- 집중력 향상 효과

  - 한 번에 하나에 집중할 수 있게 한다.
  - 개인적으로는 자바 웹 프로그래밍 하다보면 한 번에 하나씩 집중할 수 없었다


### 실수

- 테스트 자체가 목적이 되어버렸거나 (커버리지를 높이기 위한)

- 불필요한 테스트를 만드는 것

  - (불필요한 테스트를 만들지 않기 위해) 기준을 만들자
  - 비즈니스 로직과 관련된 버그를 낼 가능성이 낮거나 없는 것은
  - 테스트를 유지함으로써 얻는 이익 < 테스트 유지와 관리에 드는 비용일 때 
    - UI의 경우 굉장히 다양하게 변하는데 이에 대한 테스트를 만들다보면 조금의 변화에도 테스트가 깨진다.
  - 테스트가 단언하고 있는 내용이 사용자에게 중요한 가치를 주는 것이 아닐 때 

  위와 같은 이유일 때는 테스트를 만들지 않는다.

- 필요하지만 검증 방식이 잘못된 테스트

  - 데이터에도 문제가 없고 비즈니스 로직에도 문제가 없는데 UI가 변경됨에 따라 테스트가 깨지면 스트레스 받는다

- 검증력이 떨어지는 테스트

- 테스트 제목과 검증의 불일치

- 테스트를 앞서가는 프로덕션 코드

  - 테스트 통과만을 위해 비즈니스로직을 작성하는 것은 TDD 원칙을 위반하는 것



### 고민

- 테스트 픽스처의 생성? 관리?

- 테스트와 리팩토링을 통해 함수를 분리하는데 분리되는 함수가 많다보니 내 마음이 불안해지더라

  이에 대한 본인 회사 CTO의 답변

  **추상화 수준이 낮다**

  아주 구체적인 작은 단위의 함수들로만 분리되어 있고 그들이 조합되어 만들어지는 큰 수준의 기능은 설계되지 않았다. 그래서 추상화 수준이 낮아졌다.

  **높은 응집, 낮은 결합(함수 분리)**

  단일 기능을 가진 함수로 분리함으로써 낮은 결합은 달성했다



## 테스트를 돌보기 위한 간단한 실천 방법, 효과 - 양완수

자주 들은 질문들과 그에 대한 답변

* TDD를 실무에서 많이 하느냐?

	많이 안 한다

* Unit Test를 작성을 하고 있느냐?

	하는 부분이 있고 하지 않는 부분이 있다

* Unit Test를 통해 얻고 있는 장점을 충분하게 느끼고 있느냐?

	충분히 느낀다



TDD에 대해서 이야기하지 않습니다

테스하기 좋은 설계에 대해서 이야기하지 않습니다 

제어할 수 없는 것에 대해서 이야기하지 않습니다 (시간, DB, Networking, Mocking etc)



테스트 코드는 프로젝트 코드가 사용되는 최초의 장소이며 고객이다

모든 역사는 테스트 코드부터 시작된다



그럼에도 불구하고 당신이 테스트를 거들떠보지 않는 이유는?

귀찮다, 릴리즈 날짜, 재미가 없다



언제 테스트 코드가 만들어질까?

팀 내 git log 분석해보니깐 프로젝트 마무리 시점이나 윗선에서 커버리지 낮다고 했을 때 테스트가 만들어지더라



### 테스트가 나를 고통스럽게 하는 것

- 숨겨진 본질

  - 낮은 추상화
  - 들쭉날쭉한 추상화
  - 끊어진 논리
  - 알 수 없는 의도

- 욕심쟁이

  - **테스트가 실패하는 이유는 단 하나 (단정문은 1개여야 한다)**
  - **하나의 테스트는 오직 한 가지만 똑바로 검사해야 한다**

- 인지능력의 과부화

  - 흩어진 코드와 데이터
  - 매직넘버

- 깨지기 쉬운 것들

  - 높은 결합
  - 낮은 응집

  모든 객체는 의존을 가지는 데 의존이 높으면 다른 것들에 의해 영향을 많이 받는다



**추상이란?**

**문맥(Context) 위에서 오직 관심 있는 것들에 대해서만 집중하여 명확하게 하는 것**

1+12 = 13, 맞을 수도 있고 틀릴수도 있다, 시계의 경우 1+12는 13 => 즉 1이다

추상은 굉장히 context가 중요한 것이다



**의도를 드러낼 수 있는 가장 좋은 방법이 추상화다**

낮은 추상화에 의미를 부여해야 한다



### 테스트

어떤 데이터 픽스처를 가지고 있는가?

테스트 메서드 내에서 부차적인 정보(픽스처)를 없애고 한 메서드 안에서 추상화레벨을 맞추려고 했다. 즉, 픽스처는 setUp()으로 뺐다



**테스트를 이해한다는 것은 테스트를 하는 환경을 이해한다는 것**

* setUp메서드 안에 테스트할 대상을 옮겨둔다

```java
// 기존
Option option = new Option();
option.setDiscoutPercent("xx");
option.setSalePrice("xx");
...

// 변경
Options options = new Options(new Option("aa", "bb"), new Option("cc", "dd") ...);
```



* product, option을 다음 추상에서는 productEnv개체를 만들어 사용하게 한다, 이렇게 추상화하는 과정에서 여러 헬퍼메서드들이 생긴다

* 헬퍼메서드와 테스트 메서드와는 연관이 없다. 헬퍼메서드들을 productEnv로 옮겨서 하나의 클래스내에서 다 처리할 수 있게 한다

* 테스트 대상을 dut(device under test)로 명명한다. 

* 잘못 만들어진 테스트

  테스트가 깨졌는 데 깨진 이유를 찾으려 테스트 메서드를 탐험해야 할 때, 테스트 메서드가 여러 개를 한 번에 검증하려고 하면 탐험해야 하는 상황이 생긴다

* 테스트에서 추구하는 대칭성

* 테스트 메서드 이름을 만들 때 그냥 테스트1, 테스트2 이렇게 만들고 내부 로직은 딱 1가지 일만하게 한다. 그러면 자연스럽게 테스트 메서드의 이름이 드러난다



**거의 대부분 테스트를 잘 짜려고 했지 설계에 온전히 집중하지 않았다**

* 테스트를 가지고 현재 비즈니스를 이해하고 새로운 피처가 추가될 때 어디에 추가되어야 할지 명확해진다

* T**DD보다 더 중요시 되어야 하는 것은 테스트이다, 테스트 코드를 잘 짜야 한다**

* 테스트를 위해 수년간 수련했다



**도대체 테스트가 나에게 주는 가치는 무엇인가?**

**배움**이다

테스트 짜다가 소리 지를 때가 있다 

"이거지", "이렇게 되니깐 응집력이 높아지지" 등

테스트가 우리를 가르친다, 테스트를 통해 나의 실력이 올라간다



양완수 Helly - 쿠팡, 셀러 리스팅팀, 이커머스

Slipp에서 활동했었다

(자기소개 제일 마지막에 한 게 인상적이었는데, 이유는 더 인상적이었다. 발표가 망하면 이름도 말 안하고 그냥 내려가려고 하셨다고.)



### 질문

**지저분한데 픽스처를 어떻게 넣을 것인가?**

리팩토링하자니 시간이 없고, 픽스처를 넣자니 어렵다, 격리하자



## 당신의 TDD가 항상 실패하는 이유

너는 항상 성공하냐?

아뇨, 저도 실패해요. 하지만 항상 실패하지 않아요.



우리 프로젝트는

- 스타트업이 아니다
- 비즈니스 서비스를 만든다
- 글로벌 시장
- 많은 경쟁사들이 있다
- Message-Driven
- Multitenancy
- Scalable
- Responsive



### TDD가 실패하는 이유

왜 실패하는 것 같냐?

너희는 준비가 안 됬다!!



충분히 준비되지 않은 상태 -> 성급한 시작 -> 성급한 결과 -> 실패



#### 개인이 TDD에서 실패하는 이유

**당신은 이렇게 하지 않았다**

프로그래머가 하는 일은 사이언스보다 엔지니어링에 가깝다

프로그래머는 과학적 이론, 방법들을 통해 정해진 자원 안에서 문제를 해결하는 것



**다른 세미나에서 들었던 질문** 그에 대한 답변

왜 TDD를 하는 사람은 모든 코드를 TDD로만 작성하려 하는가?

왜 TDD 프로세스를 따르지 않으면 비난하는가?

답변 : (TDD 잘 하시는 분들) **우린 안 그러는데?**



TDD를 많이 하지만 항상 TDD를 하지 않는다

과학자가 아니라 우리는 엔지니어다

TDD가 도움이 된다면 TDD를 적극 사용한다

그러나 그렇지 않다면 TDD를 하지 않는다

(포비가 항상 말씀하시는 유연한 사고, 이 바탕에서 자기만의 논리, 기준이 있어야 한다)



만약 TDD를 사용할만한 준비가 되지 않은 팀이라면 성급히 도전하지말고

현재 잘 사용하고 있는 방법으로 프로덕트를 만들어가자



그렇다면 우리는 어디에 TDD를 적용해야 할까?

우리가 보호해야할 것은?

- AWS (X) 
- Spring (X)

얘네들은 우리가 하지 않아도 알아서 잘 굴러간다



- 도메인 (O)

우리는 도메인에 가장 많은 집중을 해야 한다



우리가 제어할 수 없는 것들

외부 세상

- 실 세계
- 인프라
- 외부 서비스
- 레거시(과거에 작성된 코드)

제어할 수 없는 것에 에너지를 쏟는 것은 낭비다



우리가 보호해야 할 것을 외부세계와 잘 분리해야 한다



### **설계**

- 낮은 결합
- 높은 응집

을 통해 도메인 모델을 보호할 수 있는 설계를 해야 한다



구현 테스트

코드가 이루려는 가치를 테스트하지 않고 각 구현에 맞는 테스트를 만드니깐 리팩토링될 때마다 테스트가 깨지고 이에 따라 수정, 재작성에 대해서 비용이 증가한다

![1539927672446](C:\Users\David\Desktop\2018OKKYCON\assets\1539927672446.png)



**설계를 테스트하라**

![1539927655096](C:\Users\David\Desktop\2018OKKYCON\assets\1539927655096.png)



정보 숨김(Information Hiding) - David Parnas

어려운 설계 결정과 변경될 가능성이 높은 설계 결정들을 다른 모듈로부터 숨기는 것



즉, 더러운 디자인(잘못된 설계)을 정보 숨김으로써 다른 모듈에게 보여지는 것을 숨겨라



**인터페이스에 테스트 접근**

인터페이스의 구현에 테스트를 맞추면 매번 수정해야 할 것이다

**테스트를 할 때 구현(implementation)이 아니라 설계(interface)에 맞춰야 한다**



**레거시와 함께 살기**

이xxxxx에서 근무할 때 혼자 TDD했다 그리고 고민했다.

레거시가 있지만 어떻게 새롭고 깔끔한 코드를 넣을 수 있을까?

내 코드를 Adapter Layer로 감싸서 레거시와 연결한다

![1539928109569](C:\Users\David\Desktop\2018OKKYCON\assets\1539928109569.png)



### 당신의 팀이 TDD에 실패하는 이유

**프로세스**

- 점진
- 반복
- fail-fast

우리는 항상 성공할 수 없다

빨리 실패해야 빨리 고칠 수 있다

빨리 실패해야 수정할만한 시간을 얻을 수 있다



**반복주기**

- 계획
- 실행
- **평가**
  - 필요하다면 어떠한 도구를 통해서든 피드백을 받아야 한다

**우리는 대부분 계획과 평가가 없이 실행(프로덕션 코드에 덤비는 것)만 한다.**

무슨 코드를 만들지 계획을 세우지 않고 코딩만 한다.

코딩이 끝나면 평가없이 commit해버린다.



**문화**

- 공유
  - 목표
  - 지식

큰 목표에 함께 눈 높이를 맞추고 있어야 팀내 작은 부분을 맞춰나갈 수 있다



**아키텍처**

- 낮은 결합
- 높은 응집
- 도메인 모델 보호



**도메인 모델과 플랫폼**

![1539928229357](C:\Users\David\Desktop\2018OKKYCON\assets\1539928229357.png)



왜 자바 개발자들은 기승전"스프링"인가?

스프링과 도메인 모델이 강하게 결합되어서 그렇다

이는 도메인 모델이 보호받이 못하는 것이다



![1539928258802](C:\Users\David\Desktop\2018OKKYCON\assets\1539928258802.png)

도메인 모델은 플랫폼 독립적으로 작성되어야 한다

플랫폼은 도메인 모델을 호스팅하는 역할만 해야지 도메인 모델을 깊숙히 파고 들어서는 안 된다



**아키텍처 사례**

![1539928384168](C:\Users\David\Desktop\2018OKKYCON\assets\1539928384168.png)



스프링을 쓰지 말자는 얘기가 아니다

스프링을 잘 활용하면서 우리 도메인 모델 코드를 오염시키지 않을 수 있다



각 레이어의 크기가 중요도



### 개발하기 전에 분명히 해야하는 것

**목적**

- 소프트웨어 사용자에게 어떤 가치를 전달할 것인가?

우리가 고통받지 않으려면 아주 명확해야 한다

이렇게 명확하게 정의된 기능이 사용자에게 좋은 가치를 전달할 것이라는 근거가 있어야 한다



심플한 그림이라도 그림을 그리고 얘기할 때랑 아닐때랑 서로의 생각이 너무 큰 차이가 난다

그리고 이를 바탕으로 개발을 한다



**분석**

- (슬라이드를 훅..넘겨버리셨..)



**작업설계**

- 소프트웨어 변경은 어떤 세부 작업들이 있는가?
- 각 작업들은 어떤 순서로 진행되어야 하는가?
- 각 작업들은 누가 담당하는가?



**ATDD + TDD**

두개를 결합하여 개발을 진행



**코드 설계**

- 작업에는 어떤 코드 변경(commit)이 필요한가?

- 항상 그러는건 아니지만, 코드 설계를 할 때 테스트케이스 이름 목록을 뽑기도 한다



**코드**

**리팩터**

- 의도노출
- 중복제거

**피드백**

- 단위 테스팅
- 코드 리뷰
- 기능 테스팅
- 수동 테스팅
- 사용자 반응 수집



### 질문

**노멀한 코찔찔이들이 어떻게 스페셜 코찔찔이들이 되었는가?**

**페어링**

코딩뿐만 아니라 태스크를 나누는 작업도 페어링을 했다

처음엔 CTO 주도로 나누고 다음 번엔 코찔찔이들에게 주도를 넘겨줬다

이 모든 것이 TDD를 준비하는 과정이다



UserStory는 비즈니스 팀이 러프하게 개발팀으로 넘겨준다

그걸 바탕으로 상세히 그림을 그린다, 논리적 오류는 없는지 체크한다

이 때 만약 문제가 발생하면 비즈니스 팀과 소통해 명확하게 한다

초기분석을 끝내는 것을 목록화 한다.



내 일을 끝냈다면 내게 할당되지 않은 유저스토리를 선택해서 진행한다



항상 그렇지는 않지만 초기에는 페어링을 통해 태스크를 쪼개는 것을 연습했다



**통합 테스트가 필요한 경우 어떻게 하는가?**

단위테스트로는 불안감이 완벽히 해소되지 않는다

결국 단위테스트가 유기적으로 결합되어서 동작해야 요구사항을 만족하는 것이다

그에 대한 해결책으로 통합테스트와 수동테스트를 하는 것이다

단위 테스트는 잘 해놓고 기능테스트는 깨지는 경우



단위 테스트로 부족하기에 수동, 기능 테스트를 한다



**외부와 연동되는 경우에는 어떻게 하는가?**

현재 서비스는 양쪽으로 서비스 통합이 필요하므로 페이크 서비스를 만들어서 우리의 서비스가 그것들와 통합이 될 수 있는지 확인한다



## 패널토크 Q&A

**수많은 방법론 중에 왜 TDD인가요?**

**왜 테스트를 하고 테스트에서 어떤 가치를 느끼는가?**

테스트를 하게 되면 프로덕션 코드에 대해 애정을 가지게 된다

테스트 덕분에 프로덕션 코드에 대한 신중함이 생긴다

**가장 빠른 피드백**이 다른 방법론보다 나은 것 같다



**어떻게 TDD를 다른 개발자들에게 전파&설득할 수 있는가?**

양완수

사실 TDD를 한다는 것은 상당히 외롭다

품질을 보증하는 방법인데 왜 우리(비즈니스쪽, 관리쪽)가 알아야 해?라는 뉘앙스가 다수다

테스트 또는 TDD가 주는 이점은 설계적인 관점이다

프로덕션에 많은 영향을 주는 게 테스트이다

테스트는 의사가 수술 전 손을 씻듯 개발자에게 아주 당연하게 일어나야 하는 부분이다



박재성

본인이 주니어 개발자라 영향력이 적다면 굳이 팀내에 억지로 전파하려 애쓰지말자

우선 나를 위한 활동으로 TDD를 하자, 남들이 하든 말든 그것은 그 다음 얘기이다

내가 꾸준히 만들어둔 클린코드를 통해 다른 사람이 그 클린코드를 통한 이점을 조금이라도 맛보아 나에게 물어온다면 그 때 전파해보자



애자일 컨설팅 김창준

개인적인 관점에서 TDD는 삶의 만족도를 높여준다

내가 하는 일에 대해 매분 단위로 피드백을 받는 것이 **직무탈진**에서 조금은 자유롭다

이 때 TDD는 피드백의 수단이 된다

TDD를 어디서 생겼는가?

애자일이란 환경이 갖춰졌을 때 TDD가 의미가 있을 수 있다



한 에피소드

유명한 개발 회사 서버 개발자

TDD 몇 년간 연습해서 나의 코드에 반영하기 시작

3년 후에는 컨퍼런스까지

그리고 나의 코드 결함도와 팀내 다른 구성원의 코드 결함도를 차트로 보여줬다

> ??? : 그래서 팀원들이 TDD를 하나요?
>
>  아니요..

TDD가 정말 효과를 보려면 나혼자보다 같이할 때 더 좋다

애자일은 모를 때 시작하는 것이다

개인을 위해서 하는 것도 맞지만 팀내에서 함께 시작하는 고민을 하는 것도 필요하다

오히려 내가 전문가가 아닐 수록 상대가 디펜시브하게 나오지 않고 협력할 가능성이 높다



박재성

리더입장에서 TDD를 하자고 하면 그래도 실패할 가능성이 높다

팀의 문제점을 팀원들이 인식하게 해서 TDD든 페어프로그래밍이든 어떤 활동을 하자고 하는 말을 리더가 하는 게 아니라 팀원들이 하자고 건의할 수 있는 환경을 리더가 조성해야 한다

팀원들이 말하게 하는 것이 중요

가장 효과적일 수 있는 활동들을 **하나씩** 적용

그리고 이렇게 활동의 적용을 통해 할 수 있다는 경험을 해보는 것이 중요하다

주니어일 때 작은 변화를 위한 시도를 계속해서 근육을 만들고

이러한 근육을 바탕으로 더 큰 변화를 만들어 갈 수 있다고 생각한다.

외롭고 힘든 싸움이니 너무 집착은 하지말고 



김창준

TDD를 도입할 때도 작게 쪼개서 하나씩 도입해보자

TDD에서는 테스트 순서도 중요하다

어떤 순서냐에 따라서 종착지가 바뀔 수 있다

첫 시작을

작지만 트리비얼(사소하게)하게 선택했을 때 코너로 몰릴 수 있다

작지만 에센셜한 것(중요한 것)을 선택해야 한다



**코드커버리지를 어떤 지표로써 사용하면 좋은가?**

한상곤

커버리지에 집착하지 말자

프로덕션 코드를 이해하는 마음으로 시작하자

명확하게 드러나고 경험한 도메인에서는 프로덕션 코드에 집중하는 게 필요하고

잘 모르고 모호한 것에 대해서는 TDD를 통해 일반화하는 것이 필요하다

매트릭스에 집중하기보다 프로덕션 코드에 집중을 하자



테스트에 관한 책 추천

정진욱

- art of unit testing

- xUnitPatterns
  - 테스트에서 일어나는 모든 상황을 패턴으로 만들어 놓았다
  - data Arrange

책을 통해 나의 지식을 검증하는 것 그리고 내가 하는 방법보다 더 나은 부분을 부분을 볼 수 있다



박재성

- 테스트주도개발
- Refactoring

책을 봐도 한계가 있다, 결국 본인이 조금씩 해야 한다



한상곤

Youtube로 리팩토링, TDD에 대한 KATA



양완수

TDD, 테스트를 책을 보고 얻은 역량은 매우 적더라

내가 의지적으로 테스트, TDD를 통해 성장하고자 하는 것이 커야 한다

**TDD, 테스트는 내 표현으로 종합예술이다 **

(아.. 여기서 큰 깨달음! 항상 자기언어로 표현하라는 말을 듣고 고민했는데 이 한 문장으로 해소되었다)



**도메인 모델과 스프링을 접점을 줄여야 하는 이유는?**

도메인 모델을 다른 플랫폼을 옮겨야 할 상황이라면?

제일 중요한 도메인 모델 개발에 집중해야 한다



박재성

의존이 없는 상태로 연습을 해야 한다.

그리고 연습하면서 하나씩 DB나 기타등등을 붙여보자



양완수

스프링은 POJO를 지향함에도 불구하고 어노테이션들이 도메인으로 많이 침투하고 있다



정진욱

도메인 모델, DTO, Persistance 오브젝트를 분리할 수 있는가?



박재성

스프링과 별개로 위의 3가지를 분리할 수 있다 다만 중복이 생긴다

3가지 로직이 짬뽕이 될 수 있다 그러나 그것이 스프링단까지 내려와서는 안 된다



한상곤

DDD를 만든 사람도 프레임워크가 도메인 모델에 침투하는 것은 어쩔 수 없다고 한다.



**레거시를 어떻게?**

이규원

가만히 두다가 비즈니스적으로 문제가 생겼을 때 건들이자

그나마도 최소한으로 건들이자



레거시에 리팩토링하지말고

새로 추가되는 것을 TDD로 접근



박재성

혼자 나서서 레거시 뜯다가 고통받지말고

팀의 문화가 그렇게 될 때 다같이 나설 수 있어야 한다

그렇게 될 때 점진적으로 리팩토링해보자



양완수

슬픈 이야기

모든 레거시를 다 뿌수겠다라고 굳은 의지와 함께 도전했으나 나에게 돌아오는 것은 연봉동결

착한 레거시와 나쁜 레거시를 구분하자

회사는 돈을 벌어야 한다

잘 돌아가는 착한 레거시는 냅두자(ㅠㅠ)



김창준

TDD든 테스트든 뭐든

ROI를 생각해야 한다

팀에서 의미없는 일을 하고 있을 수 있다





---

모든 내용을 다 옮기지 못하였고 저의 부족한 지식으로 일부 적지 못한 내용도 있으며 잘못 옮겨져 연사분들의 의도가 제대로 전달되지 않을 수 있으나 이렇게 기록하여 공유할 수 있다는 것만으로도 만족합니다:)



개인적으로 TDD, 테스트, 리팩토링에 관심이 있었고 이번 컨퍼런스를 통해 현업에 계신 분들의 현실적인 고민을 들을 수 있어서 좋았습니다.



그리고 한 가지 확실한 것은 뭐든 의식적인 연습이 필요하며 많은 시간에 걸쳐 훈련한 덕분에 TDD를 비교적 자유롭게 다루시는 것을 보았습니다.



다음에도 좋은 내용의 컨퍼런스가 열렸으면 좋겠네요!

